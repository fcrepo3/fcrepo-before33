<?xml version="1.0" encoding="UTF-8"?>
<!-- **********************************************************************************************************-->
<!-- SCHEMATRON  SCHEMA FOR FEDORA DIGITAL OBJECTS-->
<!-- TITLE:  fedoraRules.xml -->
<!-- DESCRIPTION:  This schema expresses validation rules for Fedora digital objects that -->
<!-- are NOT ALREADY EXPRESSED in the METS XML Schema.-->
<!-- AUTHOR:  Sandy Payette,  payette@cs.cornell.edu -->
<!-- *********************************************************************************************************-->
<sch:schema xmlns:sch="http://www.ascc.net/xml/schematron">
	<!-- FIGURE OUT: how to best deal with validation and namespace prefix declaration-->
	<sch:ns prefix="METS" uri="http://www.loc.gov/METS/"/>
	<sch:ns prefix="xlink" uri="http://www.w3.org/TR/xlink"/>
	<sch:ns prefix="xsi" uri="http://www.w3.org/2001/XMLSchema-instance"/>
	<!-- RULES FOR OBJECT INGEST PHASE:  These rules apply to a digital object in its "submission" format for ingest into the repository-->
	<!-- These rules are to be applied upon initial receipt of the object by the repository, before the repository has done any processing of the input.-->
	<sch:phase id="ingest">
		<sch:active pattern="preliminary"/>
	</sch:phase>
	<!-- RULES FOR OBJECT STORAGE PHASE: Rules to ensure that digital object is FULLY valid before being accepted for final storage in the repository-->
	<!-- These rules are to be applied after all processing has been done by the repository, and before it is submitted to low level storage.-->
	<sch:phase id="store">
		<sch:active pattern="preliminary"/>
		<!-- TEMPORARY COMMENT OUT OF THE COMPLETED PHASE UNTIL INGEST PROCESS -->
		<!-- IMPLEMENTS THE ASSIGNMENT OF DATES AND STATUS CODES TO THE OBJECT -->
        <!-- FIXME:Is this commenting-out still necessary? -->
		<!-- <sch:active pattern="completed"/> -->
        <sch:active pattern="harvestable1"/>
        <sch:active pattern="harvestable2"/>
	</sch:phase>
	<!-- PRELIMINARY PATTERN: -->
	<!-- These rules are to be applied to objects no matter what phase of the object lifecycle they are in.-->
	<sch:pattern name="Preliminary Object Checks" id="preliminary">
		<sch:rule context="METS:xmlData">
			<sch:assert test="child::*[not(@xsi:schemaLocation)]">Inline XML datastreams cannot contain schemaLocation attributes.</sch:assert>
		</sch:rule>
		<sch:rule context="METS:mets[@TYPE='FedoraBMechObject']">
			<sch:assert test="child::METS:amdSec[@ID='DSINPUTSPEC']">Behavior Mechanism Objects must have an inline Datastream representing a Datastream Input Spec (element amdSec with ID="DSINPUTSPEC" must exist when element mets has TYPE="FedoraBMechObject"</sch:assert>
			<sch:assert test="child::METS:amdSec[@ID='METHODMAP']">Behavior Mechanism Objects must have an inline Datastream representing a Fedora Method Map (element amdSec with ID="METHODMAP" must exist when element mets has TYPE="FedoraBMechObject"</sch:assert>
			<sch:assert test="child::METS:amdSec[@ID='WSDL']">Behavior Mechanism Objects must have an inline Datastream representing WSDL service bindings (element amdSec with ID="WSDL" must exist when element mets has TYPE="FedoraBMechObject"</sch:assert>
		</sch:rule>
		<sch:rule context="METS:mets[@TYPE='FedoraBDefObject']">
			<sch:assert test="child::METS:amdSec[@ID='METHODMAP']">Behavior Definition Objects must have an inline Datastream representing a Fedora Method Map of abstract method defs (element amdSec with ID="METHODMAP" must exist when element mets has TYPE="FedoraBDefObject"</sch:assert>
		</sch:rule>
		<sch:rule context="METS:mets">
			<sch:assert test="@TYPE = 'FedoraObject' or @TYPE = 'FedoraBDefObject' or @TYPE = 'FedoraBMechObject'">Object must be of type "FedoraObject|FedoraBDefObject|FedoraBMechObject" (element mets: TYPE)</sch:assert>
			<sch:report test="METS:dmdSec">The METS:dmdSec element is not supported by Fedora 1.0.   Use the METS:dmdSecFedora element instead (see the Fedora extension of the METS 1.0 schema)</sch:report>
		</sch:rule>
		<sch:rule context="METS:fileSec">
			<sch:assert test="METS:fileGrp[@ID]">All Datastreams must have a DatastreamID (element fileGrp: ID is missing or empty)</sch:assert>
			<sch:assert test="METS:fileGrp[@ID='DATASTREAMS']">Datastreams section encoding error (element fileSec: must have child fileGrp whose ID is "DATASTREAMS"</sch:assert>
			<sch:assert test="count(METS:fileGrp) = 1">Datastreams section encoding error (element fileSec: can only have one fileGrp as direct decendant)</sch:assert>
		</sch:rule>
		<sch:rule context="METS:fileGrp">
			<sch:assert test="@ID">Every Datastream must have a DatastreamID (element fileGrp: ID is missing)</sch:assert>
		</sch:rule>
		<sch:rule context="METS:file">
			<sch:assert test="string(@OWNERID)">Datastream control group must be recorded (element file: OWNERID missing or empty)</sch:assert>
			<sch:assert test="@OWNERID='R' or @OWNERID = 'E' or @OWNERID = 'M' or @OWNERID = 'X'">Datastream control group must be "E" for External-Ref, "M" for Managed-Internal, "R" for Redirect, or "X" for Inline-XML-User-Metadata.  (element file: OWNERID)</sch:assert>
		</sch:rule>
		<sch:rule context="METS:behaviorSec">
			<sch:assert test="string(@ID)">Every Disseminator must have a DisseminatorID (element behaviorSec: ID is missing or empty)</sch:assert>
			<sch:assert test="METS:serviceBinding[@ID]">Disseminator must have a versionID (element behaviorSec/serviceBinding: ID is missing or empty)</sch:assert>
			<sch:assert test="METS:serviceBinding/METS:interfaceMD[string(@xlink:href)]">Disseminator must point to a Behavior Definition Object (element behaviorSec/serviceBinding/interfaceMD: xlink:href is missing or empty)</sch:assert>
			<sch:assert test="METS:serviceBinding/METS:serviceBindMD[string(@xlink:href)]">Disseminator must point to a Behavior Mechanism Object (element behaviorSec/serviceBinding/serviceBindMD: xlink:href is missing or empty)</sch:assert>
		</sch:rule>
	</sch:pattern>
	<!-- COMPLETED PATTERN: -->
	<!-- These rules are to be applied to objects when they are considered completed and ready to be stored persistently in the repository.-->
	<sch:pattern name="Completed Object Checks" id="completed">
		<sch:rule context="METS:metsHdr">
			<sch:assert test="@CREATEDATE">Object must have a date of creation (element header: CREATEDATE missing)</sch:assert>
			<sch:assert test="string(@RECORDSTATUS)">Object state must be recorded (element header: RECORDSTATUS missing or empty)</sch:assert>
			<sch:assert test="@RECORDSTATUS ='A' or @RECORDSTATUS ='I' or @RECORDSTATUS ='D'">Object state value is invalid  (element header: RECORDSTATUS must be "A|I|D")</sch:assert>
		</sch:rule>
		<sch:rule context="METS:file">
			<sch:assert test="string(@STATUS)">Datastream state must be recorded (element file: STATUS missing or empty)</sch:assert>
			<sch:assert test="@STATUS= 'A' or @STATUS= 'I' or @STATUS= 'D'">Datastream state must be "A" for Active, "I" for Inactive, or "D" for Deleted.  (element file: STATUS)</sch:assert>
		</sch:rule>
		<sch:rule context="METS:behaviorSec">
			<sch:assert test="string(@STATUS)">Disseminator state must be recorded (element behaviorSec: STATUS missing or empty)</sch:assert>
			<sch:assert test="@STATUS= 'A' or @STATUS= 'I' or @STATUS= 'D'">Disseminator state must be "A" for Active, "I" for Inactive, or "D" for Deleted.  (element behaviorSec: STATUS)</sch:assert>
			<sch:assert test="METS:serviceBinding[@CREATED]">Disseminator must have a date of creation (element behaviorSec/serviceBinding: CREATED missing)</sch:assert>
		</sch:rule>
		<sch:rule context="METS:amdSec">
			<sch:assert test="@ID">Inline Metadata Datastream must have an id (element amdSec: ID missing)</sch:assert>
			<sch:assert test="string(@STATUS)">Inline Metadata Datastream state must be recorded (element amdSec: STATUS missing or empty)</sch:assert>
			<sch:assert test="@STATUS= 'A' or @STATUS= 'I' or @STATUS= 'D'">Inline Metadata Datastream state must be "A" for Active, "I" for Inactive, or "D" for Deleted.  (element amdSec: STATUS)</sch:assert>
		</sch:rule>
		<sch:rule context="METS:dmdSecFedora">
			<sch:assert test="@ID">Inline Metadata Datastream must have an id (element dmdSecFedora: ID missing)</sch:assert>
			<sch:assert test="string(@STATUS)">Inline Metadata Datastream state must be recorded (element dmdSecFedora: STATUS missing or empty)</sch:assert>
			<sch:assert test="@STATUS= 'A' or @STATUS= 'I' or @STATUS= 'D'">Inline Metadata Datastream state must be "A" for Active, "I" for Inactive, or "D" for Deleted.  (element dmdSecFedora: STATUS)</sch:assert>
		</sch:rule>
		<sch:rule context="METS:descMD">
			<sch:assert test="@CREATED">Inline Metadata Datastream must have a date of creation (element descMD: CREATED missing)</sch:assert>
			<sch:assert test="@ID">Inline Metadata Datastream must have a version id (element descMD: ID missing)</sch:assert>
		</sch:rule>
		<sch:rule context="METS:techMD">
			<sch:assert test="@CREATED">Inline Metadata Datastream must have a date of creation (element techMD: CREATED missing)</sch:assert>
			<sch:assert test="@ID">Inline Metadata Datastream must have a version id (element techMD: ID missing)</sch:assert>
		</sch:rule>
		<sch:rule context="METS:rightsMD">
			<sch:assert test="@CREATED">Inline Metadata Datastream must have a date of creation (element rightsMD: CREATED missing)</sch:assert>
			<sch:assert test="@ID">Inline Metadata Datastream must have a version id (element rightsMD: ID missing)</sch:assert>
		</sch:rule>
		<sch:rule context="METS:sourceMD">
			<sch:assert test="@CREATED">Inline Metadata Datastream must have a date of creation (element sourceMD: CREATED missing)</sch:assert>
			<sch:assert test="@ID">Inline Metadata Datastream must have a version id (element sourceMD: ID missing)</sch:assert>
		</sch:rule>
		<sch:rule context="METS:digiprovMD">
			<sch:assert test="@CREATED">Inline Metadata Datastream must have a date of creation (element digiprovMD: CREATED missing)</sch:assert>
			<sch:assert test="@ID">Inline Metadata Datastream must have a version id (element digiprovMD: ID missing)</sch:assert>
		</sch:rule>
	</sch:pattern>
  <sch:pattern name="HARVESTABLE datastreams must have a FORMATURI specified" id="harvestable1">
    <sch:rule context="METS:dmdSecFedora[@HARVESTABLE='true']" name="Check for datastreams in dmdSecFedora">
        <sch:assert test="child::node()/METS:mdWrap/@FORMATURI">
           <sch:value-of select="@ID"/> datastream has HARVESTABLE='true' but does not have a FORMATURI.
        </sch:assert>
    </sch:rule>
    <sch:rule context="METS:amdSec[@HARVESTABLE='true']" name="Check for datastreams in amdSec">
        <sch:assert test="child::node()/METS:mdWrap/@FORMATURI">
            <sch:value-of select="@ID"/> datastream has HARVESTABLE='true' but does not have a FORMATURI.
        </sch:assert>
    </sch:rule>
    <sch:rule context="METS:fileGrp[@HARVESTABLE='true']" name="Check for datastreams in fileGrp">
        <sch:assert test="METS:file/@FORMATURI">
            <sch:value-of select="@ID"/> datastream has HARVESTABLE='true' but does not have a FORMATURI.
        </sch:assert>
    </sch:rule>
  </sch:pattern>
  <sch:pattern name="There may be at most one HARVESTABLE datastream of a given FORMATURI" id="harvestable2">
    <sch:rule context="METS:dmdSecFedora[@HARVESTABLE='true']" name="Check for datastreams in dmdSecFedora">
      <sch:assert test="(count(//METS:dmdSecFedora[@HARVESTABLE='true' and child::node()/METS:mdWrap/@FORMATURI=current()/child::node()/METS:mdWrap/@FORMATURI]) + count(//METS:amdSec[@HARVESTABLE='true' and child::node()/METS:mdWrap/@FORMATURI=current()/child::node()/METS:mdWrap/@FORMATURI]) + count(//METS:fileGrp[@HARVESTABLE='true' and METS:file/@FORMATURI=current()/child::node()/METS:mdWrap/@FORMATURI]))=1">
          <sch:value-of select="@ID"/> datastream has HARVESTABLE='true' but only one datastream of format <sch:value-of select="child::node()/METS:mdWrap/@FORMATURI"/> may be harvestable in this object.
      </sch:assert>
    </sch:rule>
    <sch:rule context="METS:amdSec[@HARVESTABLE='true']" name="Check for datastreams in amdSec">
      <sch:assert test="(count(//METS:dmdSecFedora[@HARVESTABLE='true' and child::node()/METS:mdWrap/@FORMATURI=current()/child::node()/METS:mdWrap/@FORMATURI]) + count(//METS:amdSec[@HARVESTABLE='true' and child::node()/METS:mdWrap/@FORMATURI=current()/child::node()/METS:mdWrap/@FORMATURI]) + count(//METS:fileGrp[@HARVESTABLE='true' and METS:file/@FORMATURI=current()/child::node()/METS:mdWrap/@FORMATURI]))=1">
          <sch:value-of select="@ID"/> datastream has HARVESTABLE='true' but only one datastream of format <sch:value-of select="child::node()/METS:mdWrap/@FORMATURI"/> may be harvestable in this object.
      </sch:assert>
    </sch:rule>
    <sch:rule context="METS:fileGrp[@HARVESTABLE='true']" name="Check for datastreams in fileGrp">
      <sch:assert test="(count(//METS:dmdSecFedora[@HARVESTABLE='true' and child::node()/METS:mdWrap/@FORMATURI=current()/METS:file/@FORMATURI]) + count(//METS:amdSec[@HARVESTABLE='true' and child::node()/METS:mdWrap/@FORMATURI=current()/METS:file/@FORMATURI]) + count(//METS:fileGrp[@HARVESTABLE='true' and METS:file/@FORMATURI=current()/METS:file/@FORMATURI]))=1">
          <sch:value-of select="@ID"/> datastream has HARVESTABLE='true' but only one datastream of format <sch:value-of select="METS:file/@FORMATURI"/> may be harvestable in this object.
      </sch:assert>
    </sch:rule>
  </sch:pattern>
</sch:schema>
